// 一个环，有n个点, 每次只能走一步， 问从原点0出发，经过k步回到原点有多少种方法？
// 该问题转换为把环上的点编号为0 到 n-1, 即从0点出发，再回到0点有多少种方法？
// d(k, j) = d(k-1, (j-1+n)%n) + d(k-1, (j+1)%n);
// d(k,j)表示从点j走k步到达原点的方法，可以转化为他相邻的点经过k-1步回到原点的问题，由于是环的问题， j-1, j+1可能会超出 0到n-1的范围,所以取模。
// 边界条件d(0,0)=1,dp(0,1)到dp(0,n-1)均为0。

int dp[100][100];

int get_step_num(int n, int k) {
	if(n==1) return 1;
	if(n==2) {
		if(k%2==0) return 1;
		else return 0;
	}
	dp[0][0] = 1;
	for(int i=1; i<n; ++i) {
		dp[0][i] = 0;
	}
	for(int i=1; i<=k; ++i) {
		for(int j=0; j<n; ++j) {
			dp[i][j] = dp[i-1][(j-1+n)%n]+dp[i-1][(j+1)%n];
		}
	}
	return dp[k][0];
}
